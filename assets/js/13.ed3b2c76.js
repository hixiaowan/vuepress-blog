(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{575:function(t,a,s){"use strict";s.r(a);var e=s(17),l=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"javascript-执行机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript-执行机制"}},[t._v("#")]),t._v(" JavaScript 执行机制")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/21/15fdd88994142347~tplv-t2oaga2asx-watermark.awebp",alt:"执行机制"}})]),t._v(" "),s("ul",[s("li",[t._v("执行栈（call stack）\n"),s("ul",[s("li",[t._v("同步\n"),s("ul",[s("li",[t._v("主线程")])])]),t._v(" "),s("li",[t._v("异步\n"),s("ul",[s("li",[t._v("Event Table（事件列表）\n"),s("ul",[s("li",[t._v("注册回调函数")]),t._v(" "),s("li",[t._v("Event Queue（事件队列）\n"),s("ul",[s("li",[t._v("微任务队列\n"),s("ul",[s("li",[t._v("process.nextTick（node 独有），Promise，async/await")])])]),t._v(" "),s("li",[t._v("宏任务队列\n"),s("ul",[s("li",[t._v("setTimeout，setInterval，script（整体代码）， DOM 事件，AJAX 请求，requestAnimationFrame")])])])])])])])])])])])]),t._v(" "),s("h2",{attrs:{id:"event-loop-事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-事件循环"}},[t._v("#")]),t._v(" Event Loop（事件循环）")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/21/15fdcea13361a1ec~tplv-t2oaga2asx-watermark.awebp",alt:"事件循环"}})]),t._v(" "),s("ul",[s("li",[t._v("浏览器的事件循环由一个宏任务队列+多个微任务队列组成")]),t._v(" "),s("li",[t._v("每轮循环都是由一个宏任务+一个微任务队列（所有在此期间入队的微任务）组成。")])]),t._v(" "),s("h3",{attrs:{id:"常见问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[t._v("#")]),t._v(" 常见问题")]),t._v(" "),s("ul",[s("li",[t._v("如何知道主线程执行栈为空？\n"),s("ul",[s("li",[t._v("js 引擎存在 monitoring process（监测过程）进程，会持续不断的检查主线程执行栈是否为空")])])]),t._v(" "),s("li",[t._v("为什么会分为宏任务和微任务？\n"),s("ul",[s("li",[t._v("事件循环由宏任务和在执行宏任务期间产生的所有微任务组成。完成当下的宏任务后，会立刻执行所有在此期间入队的微任务。")]),t._v(" "),s("li",[t._v("这种设计是为了给紧急任务一个插队的机会，否则新入队的任务永远被放在队尾。区分了微任务和宏任务后，本轮循环中的微任务实际上就是在插队，这样微任务中所做的状态修改，在下一轮事件循环中也能得到同步。")])])])]),t._v(" "),s("h3",{attrs:{id:"注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),s("ul",[s("li",[t._v("切记 script(整体代码)是一个宏任务")]),t._v(" "),s("li",[t._v("事件循环中的任务被分为宏任务和微任务，是为了给高优先级任务一个插队的机会：==微任务比宏任务有更高优先级==。")])]),t._v(" "),s("h3",{attrs:{id:"延伸-node-环境中的事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#延伸-node-环境中的事件循环"}},[t._v("#")]),t._v(" 延伸（Node 环境中的事件循环）")]),t._v(" "),s("ul",[s("li",[t._v("Node 环境中的事件循环与浏览器事件循环的区别\n"),s("ul",[s("li",[t._v("宏任务与微任务都存在优先级排序")]),t._v(" "),s("li",[t._v("每轮循环都是由一整个宏任务队列+一个微任务队列。")]),t._v(" "),s("li",[t._v("node11 之后，node 和浏览器的规律趋同，但优先级排序依旧保留")])])])])])}),[],!1,null,null,null);a.default=l.exports}}]);